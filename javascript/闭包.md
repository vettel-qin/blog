# 知识线

什么是作用域和作用域链（表面/堆栈） => 什么是执行栈和执行上下文（执行步骤） => 什么是闭包 => 闭包的特性 => 闭包的优缺点 => 使用闭包的注意点

# 作用域和作用域链

规定变量和函数的可使用范围叫做作用域。

每一个函数都会有一个作用域，查找变量或函数时，由局部作用域到全局作用域依次查找，这些作用域的集合就称为作用域链。

```
let a = 1;

function fn() {
  function fn1() {
    function fn2() {
      let b = 2;
      console.log(a);
    }

    fn2();
  }

  fn1();
}

fn();
```

一个函数就是一个局部作用域，要在 fn2 作用域中打印 a，首先在自己所在作用域查找，如果没有就向上级作用域查找，直到查找到全局作用域，a = 1,找到了打印出值。整个查找的过程就是基于作用域链查找的。

# 执行上下文

执行上下文就是当前 javascript 代码被解析和执行时所在环境的抽象概念

## 执行上下文的类型

1. 全局执行上下文
   这是默认的、最基础的执行上下文，任何不在函数内部的代码都在全局上下文中。它做了两件事：
   （1）、创建一个全局对象，在浏览器中这个全局对象就是 window 对象。
   （2）、将 this 指针指向这个全局对象。
   一个程序中只能存在一个全局执行上下文。
2. 函数执行上下文
   每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建，一个程序中可以存在任意数量的函数执行上下文。
3. Eval 函数执行上下文
   运行在 eval 函数中的代码也获得了自己的执行上下文，不常用 eval 函数。

## 执行上下文创建阶段

当函数被调用，但未执行任何其内部代码之前，会做三件事

1. 创建变量对象
2. 创建作用域链
3. 确定 this 指向

# 执行上下文栈（执行栈）

函数多了，就有多个函数执行上下文，每次调用函数都会创建一个新的执行上下文。javascript 引擎创建了执行上下文栈来管理执行上下文，可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。

# 闭包

闭包的本质源自两点，词法作用域和函数当作值传递。
词法作用域就是内部函数可以读取函数外面的变量。
函数当作值传递，就是把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。

词法作用域

```
 let n = 666;

 function fn() {
   console.log(n++)
 }

 fn(); // 666
```

函数当作值传递

```
function fn1() {
  let n = 666;

  return function fn2() {
    console.log(n++);
  }
}

const fn3 = fn1();

fn3(); // 666

```

## 闭包特性

- 函数内再嵌套函数
- 内部函数可以引用外层的参数和变量。
- 参数和变量不会被垃圾回收机制回收。

## 闭包优缺点

使用闭包主要是为了设计私有的方法和变量。
闭包的优点

- 可以避免全局变量的污染。
- 希望一个变量长期保存内存中。
- 私有成员的存在。

闭包的缺点

- 常驻内存，会增大内存的使用量。
- 使用不当会造成内存泄露。

## 使用闭包的注意点

- 由于闭包会使得函数中的变量常驻内存中，增大内存消耗，所以不能滥用闭包，否则会造成网页的性能问题，也可能导致内存泄露。
- 解决方法是，在退出函数之前，将不使用的局部变量删除。
