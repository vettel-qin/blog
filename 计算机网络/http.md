# TCP

## TCP 三次握手

TCP 的连接建立是一个三次握手过程，目的是为了通信双方确认序列号。
![三次握手](https://github.com/vettel-qin/blog/blob/master/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号。此时客户端处于 SYN_SEND 状态。
同步位 SYN=1，初始化序列号 seq=x

第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且指定自己的初始化序列号。同时会把客户端的序列号 seq + 1 作为 ACK 值，表示自己已经收到了客户端的 SYN,此时服务器处于 SYN_REVD 的状态。
确认报文段中 SYN=1，ACK=1,确认号 ack=x+1,初始化序列号 seq=y

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，把服务器的 seq + 1 作为 ACK 的值，表示已经收到了服务器的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1

在 socket 编程中，客户端执行 connect()时，将触发三次握手。

## 四次挥手

![四次挥手](https://github.com/vettel-qin/blog/blob/master/assets/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态
即发出连接释放报文段（FIN=1,序号 seq=u）,并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1(终止等待 1)状态，等待服务器的确认。

第二次挥手：服务器收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值+1 作为 ACK 报文的序列号值。表明已经收到客户端的报文了，此时服务器处于 CLOSE_WAIT 状态
即服务器收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1,序号 seq=v）服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。

# HTTP 协议

## 1. HTTP 报文结构

header + body 的结构，具体而言：
起始行 + 头部 + 空行 + 实体

### 起始行

请求报文

```
  GET /home HTTP/1.1
```

也就是方法+路径+http 版本

响应报文

```
  HTTP/1.1 200 OK
```

响应报文的起始行也叫做状态行，由 http 版本，状态码，状态码的原因短语

### 头部

不管是请求头还是响应头，其中的字段是相当多的，例如：

```
User-Agent：产生请求的浏览器类型。
Accept：客户端可识别的内容类型列表。
Host：请求的主机名。
```

### 空行

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

### 实体

就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体

## HTTP 的请求方法

GET: 用来获取资源
HEAD: 获取报文的头部
POST: 提交数据，即上传数据
PUT: 修改数据
DELETE: 删除资源
CONNECT: 建立连接隧道，用于代理服务器
OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
TRACE: 追踪请求-响应的传输路径

## GET 与 POST 的区别

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

## HTTP 状态码

- 1xx: 表示目前是协议处理的中间状态，还需要后续操作。
- 2xx: 表示成功状态。
- 3xx: 重定向状态。
- 4xx: 请求报文有误。
- 5xx: 服务器端发生错误。

  3xx
  301 Moved Permanently：永久重定向，浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址
  302 Found：临时重定向，浏览器并不会做缓存优化。
  304 Not Modified: 当协商缓存命中时会返回这个状态码

  4xx
  400 Bad Request: 只是提示错误，并不知道哪里出错了。
  403 Forbidden: 服务器禁止访问，原因有很多，比如权限、法律禁止、信息敏感。
  404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
  405 Method Not Allowed: 请求方法不被服务器端允许。
  406 Not Acceptable: 资源无法满足客户端的条件。
  408 Request Timeout: 服务器等待了太长时间。
  409 Conflict: 多个请求发生了冲突。
  413 Request Entity Too Large: 请求体的数据过大。
  414 Request-URI Too Long: 请求行里的 URI 太大。
  429 Too Many Request: 客户端发送的请求过多。
  431 Request Header Fields Too Large 请求头的字段内容太大。

  5xx
  500 Internal Server Error: 服务器出错了，并不知道哪里出错了。
  501 Not Implemented: 表示客户端请求的功能还不支持。
  502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，不知道哪里出错了。
  503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。

## HTTP 缺点

- 无状态
- 明文传输
- 队头阻塞问题

## 数据传输

### 定长数据

对于定长包体而言，发送端在传输的时候会带上 Content-Langth,来指明包体的长度

```
res.setHeader('Content-Length', 10);
```

### 不定长数据

http 头部设置 Transfer-Encoding: chunked,表示分块传输数据，设置了这个字段后会自动产生两个效果：

- Content-Length 字段会被忽略
- 基于长连接持续推送动态内容

### HTTP 大文件的传输

对于几百 M 甚至上 G 的大文件来说，一次全部传输过来是不现实的，会有大量的等待时间，影响用户体验。HTTP 采取了范围请求的解决方案，允许客户端请求一个资源的一部分。

前提是服务器要支持范围请求，要支持这个功能，在响应头加上：Accept-Ranges: none,用来告知客户端这边是支持范围请求的

客户端通过 Range 这个请求头确定客户端需要指定请求哪一部分。格式为 bytes=x-y
. 0-499 表示从开始到第 499 个字节。
. 500- 表示从第 500 字节到文件终点。
. -100 表示文件的最后 100 个字节。

```
// 单段数据
Range: bytes=0-9
// 多段数据
Range: bytes=0-9, 30-39
```

服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回 416 错误码，否则读取相应片段，返回 206 状态码。
同时，服务器需要添加 Content-Range 字段

```
Content-Range: bytes 0-9/100
```

0-9 表示请求的返回，100 表示资源的总大小

## 队头阻塞问题

### 什么是 HTTP 队头阻塞

HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收。任务被放在一个任务队列中串行执行，一旦队头的请求处理太慢，就会阻塞后面请求的处理，这就是 HTTP 队头阻塞问题。

- 并发连接
  分配多个长连接，在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。

- 域名分片
  这样一个域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，就解决了队头阻塞的问题。

## HTTP 代理

代理服务器相当于一个中间人的角色

- 负载均衡
  客户端的请求只会先到代理服务器，有多少源服务器，IP 都是多少，客户端都是不知道的。这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性 hash 等等

- 保障安全
  利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。对非法 IP 限流，这些都是代理服务器的工作。

- 缓存代理
  将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。

## Cookie

### Cookie 简介

HTTP 是一个无状态的协议，每次 http 请求都是独立的，默认不需要保留状态信息，但有时候需要保存一些状态，怎么办呢？
因些 HTTP 引入了 Cookie。Cookie 就是浏览器里面存储一个很小的文本文件，内部以键值对的方式来存储。
在同一个域名下发送请求都会携带相同的 Cookie,服务器拿到 Cookie 进行解析，便能拿到客户端的状态了。而服务端可以通过响应头中的 Set-Cookie 字段来对客户端写入 Cookie

```
// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx
```

### Cookie 属性

### 有效期

Cookie 的有效期可以通过 EXpires 和 Max-Age 两个属性来设置

- Expires 即过期时间
- Max-Age 是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

### 作用域

Cookie 的作用域通过设置 Domain 和 path 属性给 Cookie 绑定域名和路径。在发送请求之前，发现域名或者路径和这两个属性不匹配，就不会带上 Cookie。
值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。

### 安全

如果 cookie 设置了 Secure=true，只能通过 HTTPS 传输 cookie

如果 cookie 设置了 HttpOnly=true，只能通过 HTTP 协议传输，不能通过 js 获取，无法用 document.cookie 打出 cookie 的内容。这也是预防 XSS 攻击的重要手段

相应的，对于 CSRF 攻击的预防，也有 SameSite 属性。
SameSite 可以设置为三个值，Strict、Lax 和 None。
a. 在 Strict 模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求 baidu.com 网站只能在 baidu.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。
b. 在 Lax 模式，就宽松一点了，但是只能在 get 方法提交表单情况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
c. 在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。

### Cookie 的缺点

1. 容量缺陷。Cookie 的体积上限只有 4KB。

2. 性能缺陷。在同一域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 Domain 和 Path 指定作用域来解决。

3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

## 跨域问题

### 什么是跨域

浏览器浏览器遵循同源策略(scheme(协议)、host(主机)和 port(端口)都相同则为同源)。
当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，就产生跨域，被称为跨域请求。

## HTTP/2

头部压缩
服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，在传输的时候，把索引（比如 0，1，2）传给对方，对方拿到索引查表。

多路复用
HTTP 队头阻塞：HTTP 基于请求 - 响应的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。

HTTP/2 使用二进制分帧解决队头阻塞
把 Headers + Body 的报文拆分成一个个二进制的帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。
多路复用：通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信

服务器推送
在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件（CSS，图片等）一起返回给客户端，减少客户端的等待。

对整个URL的编码：处理空格/中文等
```
encodeURI()/decodeURI()
```

主要对传递的参数信息编码：中文、空格、斜杠等
encodeURICompoent()/decodeURLComponent()

URL/URI/URN的区别

第一步
url解析
第二步
缓存检查（先检测是否存在强缓存再检测协商缓存）
第三步
DNS解析（域名解析）
性能优先使用DNS预解析 <link rel="dns-prefetch" href="" />
第四步
TCP三次握手(建立连接通道)
第五步数据传输
第六步TCP四次挥手
第七步页面渲染