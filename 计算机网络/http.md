# TCP

## TCP 三次握手

TCP 的连接建立是一个三次握手过程，目的是为了通信双方确认序列号。
![三次握手](https://github.com/vettel-qin/blog/blob/master/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号。此时客户端处于 SYN_SEND 状态。
同步位 SYN=1，初始化序列号 seq=x

第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且指定自己的初始化序列号。同时会把客户端的序列号 seq + 1 作为 ACK 值，表示自己已经收到了客户端的 SYN,此时服务器处于 SYN_REVD 的状态。
确认报文段中 SYN=1，ACK=1,确认号 ack=x+1,初始化序列号 seq=y

第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，把服务器的 seq + 1 作为 ACK 的值，表示已经收到了服务器的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1

在 socket 编程中，客户端执行 connect()时，将触发三次握手。

## 四次挥手

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态
即发出连接释放报文段（FIN=1,序号 seq=u）,并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1(终止等待 1)状态，等待服务器的确认。

第二次挥手：服务器收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值+1 作为 ACK 报文的序列号值。表明已经收到客户端的报文了，此时服务器处于 CLOSE_WAIT 状态
即服务器收到连接释放报文段后即发出确认报文段（ACK=1，确认号 ack=u+1,序号 seq=v）服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。

# HTTP 协议

## 1. HTTP 报文结构

header + body 的结构，具体而言：
起始行 + 头部 + 空行 + 实体

### 起始行

请求报文

```
  GET /home HTTP/1.1
```

也就是方法+路径+http 版本

响应报文

```
  HTTP/1.1 200 OK
```

响应报文的起始行也叫做状态行，由 http 版本，状态码，状态码的原因短语

### 头部

不管是请求头还是响应头，其中的字段是相当多的，例如：

```
User-Agent：产生请求的浏览器类型。
Accept：客户端可识别的内容类型列表。
Host：请求的主机名。
```

### 空行

最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

### 实体

就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体

## HTTP 的请求方法

GET: 用来获取资源
HEAD: 获取报文的头部
POST: 提交数据，即上传数据
PUT: 修改数据
DELETE: 删除资源
CONNECT: 建立连接隧道，用于代理服务器
OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
TRACE: 追踪请求-响应的传输路径

## GET 与 POST 的区别

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

## HTTP 状态码

- 1xx: 表示目前是协议处理的中间状态，还需要后续操作。
- 2xx: 表示成功状态。
- 3xx: 重定向状态。
- 4xx: 请求报文有误。
- 5xx: 服务器端发生错误。

  3xx
  301 Moved Permanently：永久重定向，浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址
  302 Found：临时重定向，浏览器并不会做缓存优化。
  304 Not Modified: 当协商缓存命中时会返回这个状态码

  4xx
  400 Bad Request: 只是提示错误，并不知道哪里出错了。
  403 Forbidden: 服务器禁止访问，原因有很多，比如权限、法律禁止、信息敏感。
  404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。
  405 Method Not Allowed: 请求方法不被服务器端允许。
  406 Not Acceptable: 资源无法满足客户端的条件。
  408 Request Timeout: 服务器等待了太长时间。
  409 Conflict: 多个请求发生了冲突。
  413 Request Entity Too Large: 请求体的数据过大。
  414 Request-URI Too Long: 请求行里的 URI 太大。
  429 Too Many Request: 客户端发送的请求过多。
  431 Request Header Fields Too Large 请求头的字段内容太大。

  5xx
  500 Internal Server Error: 服务器出错了，并不知道哪里出错了。
  501 Not Implemented: 表示客户端请求的功能还不支持。
  502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，不知道哪里出错了。
  503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。

## HTTP 缺点

- 无状态
- 明文传输
- 队头阻塞问题

## HTTP/2

头部压缩
服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，在传输的时候，把索引（比如 0，1，2）传给对方，对方拿到索引查表。

多路复用
HTTP 队头阻塞：HTTP 基于请求 - 响应的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。

HTTP/2 使用二进制分帧解决队头阻塞
把 Headers + Body 的报文拆分成一个个二进制的帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。
多路复用：通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信

服务器推送
在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件（CSS，图片等）一起返回给客户端，减少客户端的等待。
